/*************************************************************************************************use Perlin.fastFbm(x:Number, y:Number, z:Number, octaves:int = 4)references// http://mrl.nyu.edu/~perlin/noise/// http://ozviz.wasp.uwa.edu.au/~pbourke/texture_colour/perlin/perlin.c// robert penner*************************************************************************************************//***********************************************************************Copyright (c) 2008, Memo Akten, www.memo.tvThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.	***********************************************************************/	package msa.noise {		import msa.noise.*;		public class Perlin extends NoiseSuper {				/****** initObject parameters *******/		// common parameters				static private var noiseBasis:Function			= improved;		static private var interpolation:Function		= smooth5;		// the function used for interpolating the noise				// fBm		static private var octaves:int					= 4;			// number of frequencies in the fractal		static private var lacunarity:Number			= 2;			// gap between successive frequencies		static private var H:Number						= 0.5;			// fractal implement parameter		// multifractals		static private var offset:Number				= 0.8;		/****** END initObject parameters *******/				static private var maxAmp:Number				= 0;								static public function setParams(initObject:Object):void {						if(initObject.noiseBasis) 		noiseBasis		= initObject.noiseBasis;			if(initObject.interpolation)	interpolation	= initObject.interpolation;			if(initObject.octaves)			octaves			= initObject.octaves;			if(initObject.lacunarity)		lacunarity		= initObject.lacunarity;			if(initObject.H)				H				= initObject.H;			if(initObject.offset)			offset			= initObject.offset;						calcMax();		}										static public function fractalNoise(x:Number, y:Number, z:Number):Number {			var amp:Number = 1;			var fscale:Number = 1;			var sum:Number = 0;						if(maxAmp == 0) calcMax();			for (var i:int = 0; i < octaves; i++, amp *= H, fscale *= lacunarity) {				sum  += amp * noiseBasis(fscale*x, fscale*y, fscale*z);			}				return (sum * maxAmp + 1) * 0.5;		}								static public function turbulence(x:Number, y:Number, z:Number):Number {			var amp:Number = 1;			var fscale:Number = 1;			var sum:Number = 0;						if(maxAmp == 0) calcMax();						for (var i:int = 0; i < octaves; i++, amp *= H, fscale *= lacunarity) {				sum  += amp * Math.abs( noiseBasis(fscale*x, fscale*y, fscale*z) );			}				return (sum * maxAmp + 1) * 0.5;		}						static public function turbulenceHard(x:Number, y:Number, z:Number):Number {			var amp:Number = 1;			var fscale:Number = 1;			var sum:Number = 0;						if(maxAmp == 0) calcMax();				for (var i:int = 0; i < octaves; i++, amp *= H, fscale *= lacunarity) {				sum  += amp * Math.abs( 2 * noiseBasis(fscale*x, fscale*y, fscale*z) - 1 );			}				return (sum * maxAmp + 1) * 0.5;		}																// improved perlin noise function (to be iterated in other functions such as fractalNoise, turbulence etc.		static public function improved(x:Number, y:Number, z:Number):Number {			var X:int = Math.floor(x) & 255;					// FIND UNIT CUBE THAT CONTAINS POINT.			var Y:int = Math.floor(y) & 255;              			var Z:int = Math.floor(z) & 255;			x -= Math.floor(x);									// FIND RELATIVE X,Y,Z			y -= Math.floor(y);									// OF POINT IN CUBE.			z -= Math.floor(z);			var u:Number = interpolation(x);						// COMPUTE FADE CURVES			var v:Number = interpolation(y);						// FOR EACH OF X,Y,Z.			var w:Number = interpolation(z);			var A:int = hash[X]+Y;									// HASH COORDINATES OF THE 8 CUBE CORNERS,			var AA:int = hash[A]+Z;			var AB:int = hash[A+1]+Z;			var B:int = hash[X+1]+Y;			var BA:int = hash[B]+Z;			var BB:int = hash[B+1]+Z;						return lerp(w, lerp(v, lerp(u, grad(hash[AA  ], x  , y  , z   ),										 grad(hash[BA  ], x-1, y  , z   )), 								 lerp(u, grad(hash[AB  ], x  , y-1, z   ), 										 grad(hash[BB  ], x-1, y-1, z   ))),						 lerp(v, lerp(u, grad(hash[AA+1], x  , y  , z-1 ),  										 grad(hash[BA+1], x-1, y  , z-1 )), 								 lerp(u, grad(hash[AB+1], x  , y-1, z-1 ),										 grad(hash[BB+1], x-1, y-1, z-1 ))));		}								// returns -1...1 (needed for BLU_gnoise, BLI_gTurbuluence)		static public function improvedU(x:Number, y:Number, z:Number):Number {			return 0.5 + 0.5 * improved(x, y, z);		}				/********************* PRIVATES *********************/					static private function calcMax():void {			maxAmp = 0;			for (var i:int; i<octaves; i++) maxAmp += Math.pow(H, i);			maxAmp = 1/maxAmp;		}								}}