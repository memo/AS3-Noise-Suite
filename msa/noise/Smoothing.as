/***********************************************************************Copyright (c) 2008, Memo Akten, www.memo.tvThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.	***********************************************************************/	package  msa.noise {		public class Smoothing {				static public const functionsList:Array =[					{ data: Smoothing.linear,		label:'<none> (linear)'},				{ data: Smoothing.smooth3,		label:'smooth3'},				{ data: Smoothing.smooth5,		label:'smooth5'},								{ data: Smoothing.quadIn,		label:'quadIn'},				{ data: Smoothing.quadOut,		label:'quadOut'},				{ data: Smoothing.quadInOut,	label:'quadInOut'},								{ data: Smoothing.cubicIn,		label:'cubicIn'},				{ data: Smoothing.cubicOut,		label:'cubicOut'},				{ data: Smoothing.cubicInOut,	label:'cubicInOut'},								{ data: Smoothing.quartIn,		label:'quartIn'},				{ data: Smoothing.quartOut,		label:'quartOut'},				{ data: Smoothing.quartInOut,	label:'quartInOut'},								{ data: Smoothing.quintIn,		label:'quintIn'},				{ data: Smoothing.quintOut,		label:'quintOut'},				{ data: Smoothing.quintInOut,	label:'quintInOut'},								{ data: Smoothing.expoIn,		label:'expoIn'},				{ data: Smoothing.expoOut,		label:'expoOut'},				{ data: Smoothing.expoInOut,	label:'expoInOut'},								{ data: Smoothing.sinIn,		label:'sinIn'},				{ data: Smoothing.sinOut,		label:'sinOut'},				{ data: Smoothing.sinInOut,		label:'sinInOut'},								{ data: Smoothing.bounceIn,		label:'bounceIn'},				{ data: Smoothing.bounceOut,	label:'bounceOut'},				{ data: Smoothing.bounceInOut,	label:'bounceInOut'},								{ data: Smoothing.circIn,		label:'circIn'},				{ data: Smoothing.circOut,		label:'circOut'},				{ data: Smoothing.circInOut,	label:'circInOut'},			];								// 5th degree smoothing - default pre-smoothing for Improved Perlin noise		// both 1st and 2nd derivates are 0 at endpoints t=0 and t=1		static public function smooth5(t:Number):Number {			// npfade			return t * t * t * (t * (t * 6 - 15) + 10);		}						// 3rd degree smoothing - default pre-smoothing for Original Perlin noise		// 1st derivative is 0 at endpoints t=0 and t=1		static public function smooth3(t:Number):Number {			return t * t * (3 - 2 * t);		}						static public function linear(t:Number):Number {			return t;		}							// Based on Robert Penner's quadratic (2nd degree) easing functions		static public function quadIn (t:Number):Number {			return t * t;		}				static public function quadOut (t:Number):Number {			return -t * (t-2);		}				static public function quadInOut (t:Number):Number {			if ((t *= 2) < 1) return 0.5 * t * t;			return -0.5 * ((--t)*(t-2) - 1);		}							// Based on Robert Penner's cubic (3rd degree) easing functions		static public function cubicIn(t:Number):Number {			return t*t*t;		}		static public function cubicOut(t:Number):Number {			return (--t)*t*t + 1;		}		static public function cubicInOut (t:Number):Number {			if ((t *= 2) < 1) return 0.5*t*t*t;			return 0.5*((t-=2)*t*t + 2);		}					// Based on Robert Penner's quartic (4th degree) easing functions		static public function quartIn (t:Number):Number {			return t*t*t*t;		}				static public function quartOut (t:Number):Number {			return -((t=t/1-1)*t*t*t - 1);		}				static public function quartInOut (t:Number):Number {			if ((t *= 2) < 1) return 0.5*t*t*t*t;			return -0.5 * ((t-=2)*t*t*t - 2);		}					// Based on Robert Penner's quintic (5th degree) easing functions		static public function quintIn(t:Number):Number {			return t*t*t*t*t;		}		static public function quintOut(t:Number):Number {			return ((t=t/1-1)*t*t*t*t + 1);		}		static public function quintInOut(t:Number):Number {			if ((t *= 2) < 1) return 0.5*t*t*t*t*t;			return 0.5*((t-=2)*t*t*t*t + 2);		}							// Based on Robert Penner's exponental easing functions		static public function expoIn (t:Number):Number {			return (t==0) ? 0 : Math.pow(2, 10 * (t/1 - 1));		}		static public function expoOut (t:Number):Number {			return (t==1) ? 0+1 : (-Math.pow(2, -10 * t/1) + 1);		}		static public function expoInOut (t:Number):Number {			if (t==0 || t ==1) return t;			if ((t *= 2) < 1) return 0.5 * Math.pow(2, 10 * (t - 1));			return 0.5 * (-Math.pow(2, -10 * --t) + 2);		}						// Based on Robert Penner's sinusoidal easing functions		static public function sinIn (t:Number):Number {			return -Math.cos(t * (Math.PI/2)) + 1;		}		static public function sinOut (t:Number):Number {			return Math.sin(t * (Math.PI/2));		}		static public function sinInOut (t:Number):Number {			return -0.5 * (Math.cos(Math.PI*t) - 1);		}								// Based on Robert Penner's bounce easing functions		static public function bounceOut (t:Number):Number {			if (t < (1/2.75)) {				return (7.5625*t*t);			} else if (t < (2/2.75)) {				return (7.5625*(t-=(1.5/2.75))*t + .75);			} else if (t < (2.5/2.75)) {				return (7.5625*(t-=(2.25/2.75))*t + .9375);			} else {				return (7.5625*(t-=(2.625/2.75))*t + .984375);			}		}		static public function bounceIn (t:Number):Number {			return 1 - bounceOut (1-t);		}		static public function bounceInOut (t:Number):Number {			if (t < 0.5) return bounceIn (t*2) * 0.5;			else return bounceOut (t*2-1) * 0.5 + 00.5;		}					// Based on Robert Penner's circular easing functions				static public function circIn (t:Number):Number {			return -(Math.sqrt(1 - t*t) - 1);		}		static public function circOut (t:Number):Number {			return Math.sqrt(1 - (t=t/1-1)*t);		}		static public function circInOut (t:Number):Number {			if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t*t) - 1);			return 0.5 * (Math.sqrt(1 - (t-=2)*t) + 1);		}							}}