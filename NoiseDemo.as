/***********************************************************************Copyright (c) 2008, Memo Akten, www.memo.tvThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.	***********************************************************************/	package {	import msa.noise.*;	import msa.utils.FPSCounter;	import flash.events.*;	import flash.display.*;	import flash.geom.Point;	import flash.text.TextField;		import fl.controls.*;	import fl.events.*;	import fl.data.DataProvider;	public class NoiseDemo extends Sprite {				const BM_SIZE_SMALL:Number					= 50;			// dimensions of bitmapData for small mode		const BM_SIZE_BIG:Number					= 300;			// dimenions for large mode		const BM_SCALE:Number						= BM_SIZE_BIG / BM_SIZE_SMALL;		const HIRES_ROWSIZE							= 2;			// in hires mode only do this many rows per frame		var postFunction:Function;		var noiseFunction:Function;				var bMouse:Boolean							= false;					// whether the mouse button is down or up		var phase:Number							= Math.random() * 10000;	// the noise phase (start with a random one);		var bitmapSprite:Sprite						= null;						// the Spite holding the Bitmap holding the BitmapData		var bitmap:Bitmap							= null;						// th Bitmap holding the BitmapData		var bitmapData:BitmapData					= null;						// the BitmapData instance we'll be drawing in				var curY:int								= 0;						// counter for updateStatic mode holding current Y coordinate				function NoiseDemo():void {			createBitmap();			createBitmapData(BM_SIZE_SMALL);			initUI();			addChild(new FPSCounter());									onFunctionsChange();			//onNoiseDetailSliderChange();			onResolutionChange();		}										function createBitmap():void {			addChild( bitmapSprite = new Sprite() );			bitmapSprite.addChild( bitmap = new Bitmap(null, PixelSnapping.AUTO, true) );						bitmapSprite.x = bitmapSprite.y = 1;			bitmapSprite.addEventListener(MouseEvent.MOUSE_DOWN, onBitmapMouseDown, false, 0, true);			bitmapSprite.addEventListener(MouseEvent.MOUSE_UP, onBitmapMouseUp, false, 0, true);			bitmapSprite.addEventListener(MouseEvent.MOUSE_OUT, onBitmapMouseUp, false, 0, true);		}				function destroyBitmapData():void {			if(bitmapData) bitmapData.dispose();		}						function createBitmapData(size:int):void {			destroyBitmapData();			bitmap.bitmapData = bitmapData = new BitmapData(size, size, false, 0xFFFFFF);			bitmapSprite.width = bitmapSprite.height = BM_SIZE_BIG;			bitmap.smoothing = true;		}								function initUI():void {			// INIT CONTROLS			with(cbNoiseType) {				dataProvider = new DataProvider(FunctionsList.fractalFunctions);				selectedIndex = 0;				rowCount = 20;			}						with(perlinOptions.cbInterpolation) {				dataProvider = new DataProvider(Smoothing.functionsList);				selectedIndex = 2;				rowCount = 20;			}						with(cbPost) {				dataProvider = new DataProvider(Smoothing.functionsList);				selectedIndex = 0;				rowCount = 20;			}			with(voronoiOptions.cbVoronoiDistance) {				dataProvider = new DataProvider(FunctionsList.voronoiDistanceFunctions);				selectedIndex = 0;				rowCount = 20;			}									tfColor.autoSize = 'left';									// REGISTER EVENTS			cbNoiseType.addEventListener(Event.CHANGE, onFunctionsChange, false, 0, true);			perlinOptions.cbInterpolation.addEventListener(Event.CHANGE, onFunctionsChange, false, 0, true);			cbPost.addEventListener(Event.CHANGE, onFunctionsChange, false, 0, true);			voronoiOptions.cbVoronoiDistance.addEventListener(Event.CHANGE, onFunctionsChange, false, 0, true);						sldContrast.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);			sldBrightness.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);			perlinOptions.sldOctaves.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);			perlinOptions.sldFalloff.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);			perlinOptions.sldFreq.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);			perlinOptions.sldOffset.addEventListener(SliderEvent.CHANGE, onNoiseDetailSliderChange, false, 0, true);						chkHires.addEventListener(Event.CHANGE, onResolutionChange, false, 0, true);						tfSeed.addEventListener(Event.CHANGE, onSeedChange, false, 0, true);		}				/********************* EVENT HANDLERS *********************/		function onFunctionsChange(e:Event = null):void {			noiseFunction = cbNoiseType.selectedItem.data;						//if(						voronoiOptions.visible = (cbNoiseType.selectedLabel.search('Voronoi')>-1);		// only show Voronoi options if Voronoi noise selected;						perlinOptions.visible = (!voronoiOptions.visible) && (cbNoiseType.selectedLabel.search('improvedU') === -1);						Perlin.setParams( { interpolation : perlinOptions.cbInterpolation.selectedItem.data } );						postFunction = cbPost.selectedItem.data;						Voronoi.setParams( { distFunc : voronoiOptions.cbVoronoiDistance.selectedItem.data } );		}						// set noiseDetail depending on sliders		function onNoiseDetailSliderChange(e:SliderEvent = null):void {			//Noise.noiseDetail(sldOctaves.value, sldFalloff.value, sldFreq.value, sldOffset.value);			Perlin.setParams( {octaves:perlinOptions.sldOctaves.value, H:perlinOptions.sldFalloff.value, lacunarity:perlinOptions.sldFreq.value } );			tfContrast.text = String(sldContrast.value);			tfBrightness.text = String(sldBrightness.value);			perlinOptions.tfOctaves.text = String(perlinOptions.sldOctaves.value);			perlinOptions.tfFalloff.text = String(perlinOptions.sldFalloff.value);			perlinOptions.tfFreq.text = String(perlinOptions.sldFreq.value);			perlinOptions.tfOffset.text = String(perlinOptions.sldOffset.value);						perlinOptions.sldFalloff.enabled = perlinOptions.sldFreq.enabled = perlinOptions.sldOffset.enabled = (perlinOptions.sldOctaves.value > 1);		}						function onSeedChange(e:Event = null):void {			var s = Number(e.target.text);			if(!s) s = e.target.text = 0;			//Noise.seed(s);		}						function onResolutionChange(e:Event = null):void {			if(chkHires.selected) {				removeEventListener(Event.ENTER_FRAME, updateLores);				addEventListener(Event.ENTER_FRAME, updateHires, false, 0, true);				createBitmapData(BM_SIZE_BIG);				curY = 0;			} else {				removeEventListener(Event.ENTER_FRAME, updateHires);				addEventListener(Event.ENTER_FRAME, updateLores, false, 0, true);				createBitmapData(BM_SIZE_SMALL);			}					}						// the updateAnimated function, draw the noise, updateAnimated colorswatch etc		function updateLores(e:Event):void {			var x:Number;			var y:Number;			bitmapData.lock();			for (y = 0; y < BM_SIZE_SMALL; y++)				for (x = 0; x < BM_SIZE_SMALL; x++) drawNoise(x, y, BM_SCALE);			bitmapData.unlock();			phase += sldSpeed.value;								checkMouse();		}						function updateHires(e:Event):void {			var x:Number;			var y:Number;			bitmapData.lock();			for (y = curY; y < curY + HIRES_ROWSIZE; y++)				for (x = 0; x < BM_SIZE_BIG; x++) drawNoise(x, y, 1);			bitmapData.unlock();						curY += HIRES_ROWSIZE;			if(curY == BM_SIZE_BIG) {				curY = 0;				phase += sldSpeed.value;			}			checkMouse();		}						function drawNoise(x:Number, y:Number, r:Number):void {			var i:Number = (x * r - BM_SIZE_BIG * 0.5) / sldScale.value + sldTranslateX.value;			var j:Number = (y * r - BM_SIZE_BIG * 0.5) / sldScale.value + sldTranslateY.value;							var n:Number = int( 255 * MathUtils.clamp(postFunction (MathUtils.contrast (MathUtils.brightness( noiseFunction(i, j, phase), sldBrightness.value), sldContrast.value) ) ));			//var n:Number = int(255 * noiseFunction(i, j, phase) );			bitmapData.setPixel(x, y, n + (n << 8) + (n << 16));		}								function checkMouse():void {			if (bMouse) {				var col:int = bitmapData.getPixel(bitmapSprite.mouseX, bitmapSprite.mouseY);				tfColor.text = '0x' + col.toString(16);				with(colorBox.graphics) {					clear();					lineStyle(1, 0);					beginFill(col);					drawRect(0, 0, 40, 40);				}			}		}						function onBitmapMouseDown(e:MouseEvent)	{ bMouse = true; }		function onBitmapMouseUp(e:MouseEvent)		{ bMouse = false;}				}}